% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RDPG.R
\name{NonPar.RDPG.CPD}
\alias{NonPar.RDPG.CPD}
\title{Change point detection for dependent dynamic random dot product graph models.}
\usage{
NonPar.RDPG.CPD(data_mat, d, Alpha, Beta, delta)
}
\arguments{
\item{data_mat}{A \code{numeric} matrix of observations with horizontal axis being time, and vertical axis being vectorized adjacency matrix.}

\item{d}{A \code{numeric} scalar used in the scaledPCA algorithm, which corresponds to the number of leading singular values of an adjacency matrix considered.}

\item{Alpha}{A \code{integer} vector of starting indices of random intervals.}

\item{Beta}{A \code{integer} vector of ending indices of random intervals.}

\item{delta}{A positive \code{integer} scalar of minimum spacing.}

\item{...}{Additional arguments.}
}
\value{
A \code{numeric} vector of estimated changepoint locations.
}
\description{
Perform Change point detection for dependent dynamic random dot product graph models.
}
\examples{
### generate data 
d = 10
n = 100
M = 120
delta = 5
obs_num = 150
rho_a = 0.9
v = c(floor(obs_num/3)+1, 2*floor(obs_num/3)+1)
data_mat = matrix(0, n^2, obs_num)
for(t in 1:obs_num){
  if(t == 1 || t == v[2]+1){
    P = matrix(0.3,n,n)
    P[1:floor(n/4), 1:floor(n/4)] = 0.5
    P[(1+floor(n/4)):(2*floor(n/4)),(1+floor(n/4)):(2*floor(n/4))] = 0.5
    P[(1+2*floor(n/4)):(3*floor(n/4)),(1+2*floor(n/4)):(3*floor(n/4))] = 0.5
    P[(1+3*floor(n/4)):n,(1+3*floor(n/4)):n] = 0.5
    diag(P) = 0
    A = matrix(rbinom(matrix(1,n,n),matrix(1,n,n),P),n,n)
    aux = drop(A)
    aux[lower.tri(aux)] = t(aux)[lower.tri(aux)]
    diag(aux) = 0
    data_mat[,t] = drop(matrix(aux,n^2,1))
  }
  if((t > 1 && t <= v[1]) || (t > v[2]+1)){
    aux1 = P + (1-P)*rho_a
    aux2 = P*(1-rho_a)
    aux1 = matrix(rbinom(matrix(1,n,n),matrix(1,n,n),aux1),n,n)
    aux2 = matrix(rbinom(matrix(1,n,n),matrix(1,n,n),aux2),n,n)
    A =  aux1*A + aux2*(1-A)
    aux = drop(A)
    aux[lower.tri(aux)] = t(aux)[lower.tri(aux)]  
    diag(aux) = 0
    data_mat[,t] = drop(matrix(aux,n^2,1))
  }
  if(t == v[1]+1){
    Q = matrix(0.2,n,n)
    Q[1:floor(n/4), 1:floor(n/4)] = 0.45
    Q[(1+floor(n/4)):(2*floor(n/4)),(1+floor(n/4)):(2*floor(n/4)) ] = 0.45
    Q[(1+2*floor(n/4)):(3*floor(n/4)),(1+2*floor(n/4)):(3*floor(n/4)) ] = 0.45
    Q[(1+3*floor(n/4)):n,(1+3*floor(n/4)):n ] = 0.45
    diag(Q) = 0
    A = matrix(rbinom(matrix(1,n,n),matrix(1,n,n),Q),n,n)
    aux = drop(A)
    aux[lower.tri(aux)] = t(aux)[lower.tri(aux)]  
    diag(aux) = 0
    data_mat[,t] = drop(matrix(aux,n^2,1))
  }
  if(t > v[1]+1 && t <= v[2]){
    aux1 = Q + (1-Q)*rho_a
    aux2 = Q*(1-rho_a)
    aux1 = matrix(rbinom(matrix(1,n,n),matrix(1,n,n),aux1),n,n)
    aux2 = matrix(rbinom(matrix(1,n,n),matrix(1,n,n),aux2),n,n)
    A = aux1*A + aux2*(1-A)
    aux = drop(A)
    aux[lower.tri(aux)] = t(aux)[lower.tri(aux)]  
    diag(aux) = 0
    data_mat[,t] = drop(matrix(aux,n^2,1))
  }
}
intervals = WBS.intervals(M = M, lower = 1, upper = obs_num)
cpt_hat = NonPar.RDPG.CPD(data_mat, d, Alpha = intervals$Alpha, Beta = intervals$Beta, delta)

}
\author{
Oscar Hernan Madrid Padilla, Haotian Xu
}
