% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/network_with_missing.R
\name{calibrate.network.missing}
\alias{calibrate.network.missing}
\title{Online change point detection for network data with missing values.}
\usage{
calibrate.network.missing(
  train_miss_list,
  train_eta_list,
  threshold_len,
  alpha_grid,
  permu_num,
  pi_lb_hat,
  pi_ub_hat,
  rho_hat,
  rank_hat,
  C_lambda,
  delta = 5,
  ...
)
}
\arguments{
\item{permu_num}{An \code{integer} scalar of number of random permutation for calibration.}

\item{...}{Additional arguments.}

\item{data_mat1}{A \code{numeric} matrix of observations with with horizontal axis being time, and with each column be the vectorized adjacency matrix.}

\item{data_mat2}{A \code{numeric} matrix of observations with with horizontal axis being time, and with each column be the vectorized adjacency matrix (data_mat1 and data_mat2 are independent and have the same dimensions ).}

\item{b_vec}{A \code{numeric} vector of thresholds b_t with t >= 2.}

\item{train_mat}{A \code{numeric} matrix of training data from a pre-change distribution(no change point), which is only needed to when b_vec is NULL in order to calibrate b_t.}

\item{alpha}{A \code{numeric} scalar in (0,1) representing the level.}

\item{gamma}{An \code{integer} scalar of desired average run length.}
}
\value{
A \code{list} with the following structure:
 \item{cpt}{Estimated change point}
 \item{score}{A \code{numeric} vector of computed cumsum statistics}
 \item{b_vec}{A \code{numeric} vector of thresholds b_t with t >= 2}
}
\description{
Perform online change point detection for network data by controlling the false alarm rate at level alpha or controlling the average run length gamma. The default choice of the tuning parameters tau1, tau2 and tau3 are used (see Section 4.1 of the reference).
}
\examples{
p = 12 # number of nodes
rho = 0.5 # sparsity parameter
block_num = 3 # number of groups for SBM
train_obs_num = 200 # sample size for each segment
conn1_mat = rho * matrix(c(0.6,1,0.6,1,0.6,0.5,0.6,0.5,0.6), nrow = 3) # connectivity matrix 
set.seed(1)
can_vec = sample(1:p, replace = F) # randomly assign nodes into groups
sbm = simu.SBM(conn1_mat, can_vec, train_obs_num, symm = TRUE, self = TRUE)
train_mat = sbm$obs_mat
train_list = lapply(1:ncol(train_mat), function(t) lowertri2mat(train_mat[,t], p, diag = TRUE))
pi_mat = matrix(0.9, p, p)
train_eta_list = lapply(1:length(train_list), function(t) gen.missing(pi_mat, symm = TRUE))
train_miss_list = lapply(1:length(train_list), function(t) train_eta_list[[t]] * train_list[[t]])
pi_lb_hat = quantile(Reduce("+", train_eta_list)/train_obs_num, 0.05) # estimator of pi_lb
pi_ub_hat = quantile(Reduce("+", train_eta_list)/train_obs_num, 0.95) # estimator of pi_ub
C_lambda = 2/3
graphon_miss_impute = softImpute.network.missing(train_miss_list, train_eta_list, lambda.network.missing(1, length(train_miss_list), length(train_miss_list), 0.05, rho = 0.509, m = pi_ub_hat, p, C_lambda), 1)
graphon_miss_hat = graphon_miss_impute$u \%*\% diag(as.numeric(graphon_miss_impute$d)) \%*\% t(graphon_miss_impute$v)
rho_hat = quantile(graphon_miss_hat, 0.95)
rank_hat = sum(graphon_miss_impute$d != 0)
alpha_grid = c(0.05, 0.01)
permu_num = 100
threshold_len = 300
temp = calibrate.network.missing(train_miss_list, train_eta_list, threshold_len, alpha_grid, permu_num, pi_lb_hat, pi_ub_hat, rho_hat, rank_hat, C_lambda, delta = 5)
}
\references{
Yu Y, Padilla, O, Wang D, Rinaldo A. Optimal network online change point localisation. arXiv preprint arXiv:2101.05477.
}
\author{
Haotian Xu
}
